//////////////////////////////////////////////////////////////
// Обучалка по микроконтроллерам AVR и их программирование  //
// на языке Assembler от Романа Звездопадова                //
// Автор вк: https://vk.com/zvezdopezdov                    //
// Группа вк: https://vk.com/sitrixcorp                     //
// Канал YouTube:                                           //
// https://www.youtube.com/channel/UCHyuvaL_iMYifT3ziWEuogg //
// Если вам помогли видео можете пожертвовать пару долларов //
// на развитие проекта на кошелек Payeer: P27929796  =)     //
//////////////////////////////////////////////////////////////

.include "m16def.inc" // Подключаем заголовочный файл
.def temp = r16 // Присваиваем регистрам символические имена
.def razr1 = r17
.def razr2 = r18
.def razr3 = r19

.equ FREQ = 8000000 // Частота процессора 	
.equ W1_DDR = DDRA // Регистр порта Датчика
.equ W1_PORT = PORTA // Регистр порта Датчика
.equ W1_PIN = PINA // Регистр порта Датчика
.equ W1_BIT = 0 // Бит порта на котором датчик

.dseg
Trm: // Ячейки ОЗУ под температуру
.byte 2

.cseg // Программный сегмент
.org 0 // Вектор прерывания Reset
jmp Reset // Переходим на Reset

Reset:
ldi temp, high(RAMEND) // Инициализируем стек
out sph, temp
ldi temp, low(RAMEND)
out spl, temp

rcall W1_Sbros // Сбрасываем шину и проверяем есть ли датчик
cpi r17, 0 // После сброса, если датчик есть в r17 будет 1
breq Proga_not // Если нету, уходим в бесконечность лени
rcall W1_Init_12bit // Перестраиваем конфигурационный байт на 12 битную схему работы

Proga:
rcall W1_Sbros // Сбрасываем шину и проверяем есть ли датчик
cpi r17, 0 // После сброса, если датчик есть в r17 будет 1
breq Proga_not // Если нету, уходим в бесконечность лени
rcall W1_ConvTemp // Говорим датчику конвертировать температуру

rcall Delay // Подождем пару секунд, пока датчик закончит конвертировать

rcall W1_Sbros // Сбрасываем шину и проверяем есть ли датчик
cpi r17, 0
breq Proga_not // Если нету, уходим в бесконечность лени
rcall W1_ReadMem // Читаем в ОЗУ текущую температуру

rjmp Proga // Зацикливаем

Proga_not: // Сюда приходим если датчика нету
rjmp Proga_not // и ничего больше не делаем


//////////////////////////// Начало подпрограмм 1-Wire
W1_Sbros: // Сброс шины и проверка датчик на месте ли
//lds r16, W1_BIT // Записываем в r16 ножку где датчик(не полезная)
sbi W1_DDR, W1_BIT // Ногу на выход
cbi W1_PORT, W1_BIT // Опрокидываем вывод на землю
rcall W1_DelayH // Задержка 480 мкс, для сброса
cbi W1_DDR, W1_BIT // Ногу на вход
rcall W1_DelayI // Ждем тайм слот 70 мкс
sbis W1_PIN, W1_BIT // Пропускаем следующую строку, если бит порта в 1
ldi r17, 1 // И установим сигнальный регистр в 1
sbic W1_PIN, W1_BIT // Пропускаем следующую строку, если бит порта в 0
ldi r17, 0 // И установим сигнальный регистр в 0
rcall W1_DelayJ //Ждем тайм слот 410 мкс
ret // Если датчик на месте, в r17 по выходу отсюда будет 1, в противном случае 0

W1_ReadMem: // Чтение памяти регистров температуры
ldi r16, 0xCC // Пошлем команду 0xCC, это пропустить уникальный номер датчика
rcall ds_byte_wr // Так как он у нас один на проводе
ldi r16, 0xBE // Говорим датчику, что мы сейчас будем читать
rcall ds_byte_wr // Запуливаем байт
rcall ds_byte_rd // А тут уже начинаем читать, прочитали первый
sts Trm, r16 // И запулили его в память, по метке Trm
rcall ds_byte_rd // Читаем второй
sts Trm+1, r16 // И запулили его в память, по метке Trm+1
ret

W1_ConvTemp: // Подпрограмма конвертирования температуры
ldi r16, 0xCC // Пропускаем уникальный номер датчика
rcall ds_byte_wr
ldi r16, 0x44 // Говорим что надо бы сконвертировать температуру, этот процесс занимает 750
rcall ds_byte_wr // миллисекунд, поэтому идем что-то делать, или ленится
ret

W1_Init_12bit: // Подпрограмма перестройки на 12 бит температуры
ldi r16, 0xCC  // Пропускаем уникальный номер датчика(осуществляется пропуск адреса,CC-команда пзу)
rcall ds_byte_wr // Спуливаем в датчик
ldi r16, 0x4E // Говорим что сейчас будем писать в RAM регистры датчика(4Е запись данных в регистры устройства)
rcall ds_byte_wr // Спуливаем в датчик
ldi r16, 0xFF // 0xFF записываем в первые 2 регистра, это регистры температуры, он нам не 
rcall ds_byte_wr // нужен, поэтому их оставляем в стандартном состоянии
ldi r16, 0xFF // 0xFF второй байт температуры
rcall ds_byte_wr // Спуливаем на порт
ldi r16, 0x7F // А вот тут говорим что 12 бит - 7F, или 1F  - 9бит, 3F - 10 бит, 5F - 11 бит 
rcall ds_byte_wr // Спуливаем на порт
ret

ds_byte_rd: // Подпрограмма чтения данных в регистр r16 с 1 Wire
ldi r17, 8 // Пишем в r17 - 8, т.к. у нас в бит в регистре
clr r16 // Чистим r16, сюда будем читать данные
ds_byte_rd_0:
sbi W1_DDR, W1_BIT // Вывод на выход
cbi W1_PORT, W1_BIT // Опрокидываем вывод на землю
rcall W1_DelayA // Ждем 6 микросекунд
cbi W1_DDR, W1_BIT // Вывод на вход
rcall W1_DelayE // Ждем 9 микросекунд
sbis W1_PIN, W1_BIT
clc // Очищаем бит C = 0
sbic W1_PIN, W1_BIT
sec // Очищаем бит C = 1
ror r16 // Производим циклический сдвиг вправо через С
rcall W1_DelayF // Ждем 55 микросекунд
dec r17 // Понижаем на 1 регистр r17
brne ds_byte_rd_0 // если не равен 0 вращаемся в цикле
ret
// Побитное выставление команды/данных на шину 1wire
ds_byte_wr: // Подпрограмма записи данных из регистра r16 в датчик 
ldi r17, 8 // Пишем в r17 - 8, т.к. у нас 8 бит в регистре
ds_byte_wr0: 
sbi W1_DDR, W1_BIT // Вывод на выход
cbi W1_PORT, W1_BIT // Опрокидываем вывод на землю
sbrc r16, 0 // Проверим, в r16 бит 0 очищен или установлен 
rjmp ds_byte_write_1 // Если установлен перейдем по этой метке
rjmp ds_byte_write_0 // Если очищен перейдем по этой метке
ds_byte_wr1:
lsr r16 // Логический сдвиг вправо
dec r17 // Понижаем r17 на 1 
brne ds_byte_wr0 // Если не равен 0, вращаемся в цикле
ret // Выход из подпрограммы

ds_byte_write_0: // Запись 0
rcall W1_DelayC // Ждем 60 микросекунд
cbi W1_DDR, W1_BIT // Вывод на вход
rcall W1_DelayD // Ждем 10 микросекунд
rjmp ds_byte_wr1

ds_byte_write_1: // Запись 1
rcall W1_DelayA // Ждем 6 микросекунд
cbi W1_DDR, W1_BIT // Вывод на вход
rcall W1_DelayB // Ждем 64 микросекунд
rjmp ds_byte_wr1

W1_DelayA: // Задержка 6 mcs
ldi XH, high(FREQ/1000000)
ldi XL, low(FREQ/1000000)
rcall W1_Delay
ret
W1_DelayB: // Задержка 64 mcs
ldi XH, high(FREQ/65000)
ldi XL, low(FREQ/65000)
rcall W1_Delay
ret
W1_DelayC: // Задержка 60 mcs
ldi XH, high(FREQ/68000)
ldi XL, low(FREQ/68000)
rcall W1_Delay
ret
W1_DelayD: // Задержка 10 mcs
ldi XH, high(FREQ/500000)
ldi XL, low(FREQ/500000)
rcall W1_Delay
ret
W1_DelayE: // Задержка 9 mcs
ldi XH, high(FREQ/600000)
ldi XL, low(FREQ/600000)
rcall W1_Delay
ret
W1_DelayF: // Задержка 55 mcs
ldi XH, high(FREQ/75000)
ldi XL, low(FREQ/75000)
rcall W1_Delay
ret
W1_DelayH: // Задержка 480 mcs
ldi XH, high(FREQ/8332)
ldi XL, low(FREQ/8332)
rcall W1_Delay
ret
W1_DelayI: // Задержка 70 mcs
ldi XH, high(FREQ/58000)
ldi XL, low(FREQ/58000)
rcall W1_Delay
ret
W1_DelayJ: // Задержка 410 mcs
ldi XH, high(FREQ/9756)
ldi XL, low(FREQ/9756)
rcall W1_Delay
ret
W1_Delay: // Подпрограмма воспроизведения задержки
sbiw XH:XL, 1 // Вычитаем единицу из регистровой пары
brne W1_Delay // Если не равно 0 крутимся в цикле
ret // Выход из подпрограммы
//////////////////////////// Конец подпрограмм 1-Wire

Delay: // Стандартная задержка
ldi razr1, 255
ldi razr2, 255
ldi razr3, 10
Pdelay:
dec razr1
brne Pdelay
dec razr2
brne Pdelay
dec razr3
brne Pdelay
ret
